// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/breadchris/hn/ent/item"
	"github.com/breadchris/hn/ent/predicate"
)

// ItemUpdate is the builder for updating Item entities.
type ItemUpdate struct {
	config
	hooks    []Hook
	mutation *ItemMutation
}

// Where appends a list predicates to the ItemUpdate builder.
func (iu *ItemUpdate) Where(ps ...predicate.Item) *ItemUpdate {
	iu.mutation.Where(ps...)
	return iu
}

// SetDeleted sets the "deleted" field.
func (iu *ItemUpdate) SetDeleted(b bool) *ItemUpdate {
	iu.mutation.SetDeleted(b)
	return iu
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableDeleted(b *bool) *ItemUpdate {
	if b != nil {
		iu.SetDeleted(*b)
	}
	return iu
}

// SetType sets the "type" field.
func (iu *ItemUpdate) SetType(i item.Type) *ItemUpdate {
	iu.mutation.SetType(i)
	return iu
}

// SetNillableType sets the "type" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableType(i *item.Type) *ItemUpdate {
	if i != nil {
		iu.SetType(*i)
	}
	return iu
}

// SetBy sets the "by" field.
func (iu *ItemUpdate) SetBy(s string) *ItemUpdate {
	iu.mutation.SetBy(s)
	return iu
}

// SetNillableBy sets the "by" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableBy(s *string) *ItemUpdate {
	if s != nil {
		iu.SetBy(*s)
	}
	return iu
}

// ClearBy clears the value of the "by" field.
func (iu *ItemUpdate) ClearBy() *ItemUpdate {
	iu.mutation.ClearBy()
	return iu
}

// SetText sets the "text" field.
func (iu *ItemUpdate) SetText(s string) *ItemUpdate {
	iu.mutation.SetText(s)
	return iu
}

// SetNillableText sets the "text" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableText(s *string) *ItemUpdate {
	if s != nil {
		iu.SetText(*s)
	}
	return iu
}

// ClearText clears the value of the "text" field.
func (iu *ItemUpdate) ClearText() *ItemUpdate {
	iu.mutation.ClearText()
	return iu
}

// SetDead sets the "dead" field.
func (iu *ItemUpdate) SetDead(b bool) *ItemUpdate {
	iu.mutation.SetDead(b)
	return iu
}

// SetNillableDead sets the "dead" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableDead(b *bool) *ItemUpdate {
	if b != nil {
		iu.SetDead(*b)
	}
	return iu
}

// SetParent sets the "parent" field.
func (iu *ItemUpdate) SetParent(i int) *ItemUpdate {
	iu.mutation.ResetParent()
	iu.mutation.SetParent(i)
	return iu
}

// SetNillableParent sets the "parent" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableParent(i *int) *ItemUpdate {
	if i != nil {
		iu.SetParent(*i)
	}
	return iu
}

// AddParent adds i to the "parent" field.
func (iu *ItemUpdate) AddParent(i int) *ItemUpdate {
	iu.mutation.AddParent(i)
	return iu
}

// ClearParent clears the value of the "parent" field.
func (iu *ItemUpdate) ClearParent() *ItemUpdate {
	iu.mutation.ClearParent()
	return iu
}

// SetPoll sets the "poll" field.
func (iu *ItemUpdate) SetPoll(i int) *ItemUpdate {
	iu.mutation.ResetPoll()
	iu.mutation.SetPoll(i)
	return iu
}

// SetNillablePoll sets the "poll" field if the given value is not nil.
func (iu *ItemUpdate) SetNillablePoll(i *int) *ItemUpdate {
	if i != nil {
		iu.SetPoll(*i)
	}
	return iu
}

// AddPoll adds i to the "poll" field.
func (iu *ItemUpdate) AddPoll(i int) *ItemUpdate {
	iu.mutation.AddPoll(i)
	return iu
}

// ClearPoll clears the value of the "poll" field.
func (iu *ItemUpdate) ClearPoll() *ItemUpdate {
	iu.mutation.ClearPoll()
	return iu
}

// SetKids sets the "kids" field.
func (iu *ItemUpdate) SetKids(i []int) *ItemUpdate {
	iu.mutation.SetKids(i)
	return iu
}

// AppendKids appends i to the "kids" field.
func (iu *ItemUpdate) AppendKids(i []int) *ItemUpdate {
	iu.mutation.AppendKids(i)
	return iu
}

// ClearKids clears the value of the "kids" field.
func (iu *ItemUpdate) ClearKids() *ItemUpdate {
	iu.mutation.ClearKids()
	return iu
}

// SetURL sets the "url" field.
func (iu *ItemUpdate) SetURL(s string) *ItemUpdate {
	iu.mutation.SetURL(s)
	return iu
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableURL(s *string) *ItemUpdate {
	if s != nil {
		iu.SetURL(*s)
	}
	return iu
}

// ClearURL clears the value of the "url" field.
func (iu *ItemUpdate) ClearURL() *ItemUpdate {
	iu.mutation.ClearURL()
	return iu
}

// SetScore sets the "score" field.
func (iu *ItemUpdate) SetScore(i int) *ItemUpdate {
	iu.mutation.ResetScore()
	iu.mutation.SetScore(i)
	return iu
}

// SetNillableScore sets the "score" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableScore(i *int) *ItemUpdate {
	if i != nil {
		iu.SetScore(*i)
	}
	return iu
}

// AddScore adds i to the "score" field.
func (iu *ItemUpdate) AddScore(i int) *ItemUpdate {
	iu.mutation.AddScore(i)
	return iu
}

// ClearScore clears the value of the "score" field.
func (iu *ItemUpdate) ClearScore() *ItemUpdate {
	iu.mutation.ClearScore()
	return iu
}

// SetTitle sets the "title" field.
func (iu *ItemUpdate) SetTitle(s string) *ItemUpdate {
	iu.mutation.SetTitle(s)
	return iu
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableTitle(s *string) *ItemUpdate {
	if s != nil {
		iu.SetTitle(*s)
	}
	return iu
}

// ClearTitle clears the value of the "title" field.
func (iu *ItemUpdate) ClearTitle() *ItemUpdate {
	iu.mutation.ClearTitle()
	return iu
}

// SetParts sets the "parts" field.
func (iu *ItemUpdate) SetParts(i []int) *ItemUpdate {
	iu.mutation.SetParts(i)
	return iu
}

// AppendParts appends i to the "parts" field.
func (iu *ItemUpdate) AppendParts(i []int) *ItemUpdate {
	iu.mutation.AppendParts(i)
	return iu
}

// ClearParts clears the value of the "parts" field.
func (iu *ItemUpdate) ClearParts() *ItemUpdate {
	iu.mutation.ClearParts()
	return iu
}

// SetDescendants sets the "descendants" field.
func (iu *ItemUpdate) SetDescendants(i int) *ItemUpdate {
	iu.mutation.ResetDescendants()
	iu.mutation.SetDescendants(i)
	return iu
}

// SetNillableDescendants sets the "descendants" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableDescendants(i *int) *ItemUpdate {
	if i != nil {
		iu.SetDescendants(*i)
	}
	return iu
}

// AddDescendants adds i to the "descendants" field.
func (iu *ItemUpdate) AddDescendants(i int) *ItemUpdate {
	iu.mutation.AddDescendants(i)
	return iu
}

// ClearDescendants clears the value of the "descendants" field.
func (iu *ItemUpdate) ClearDescendants() *ItemUpdate {
	iu.mutation.ClearDescendants()
	return iu
}

// SetTime sets the "time" field.
func (iu *ItemUpdate) SetTime(i int) *ItemUpdate {
	iu.mutation.ResetTime()
	iu.mutation.SetTime(i)
	return iu
}

// SetNillableTime sets the "time" field if the given value is not nil.
func (iu *ItemUpdate) SetNillableTime(i *int) *ItemUpdate {
	if i != nil {
		iu.SetTime(*i)
	}
	return iu
}

// AddTime adds i to the "time" field.
func (iu *ItemUpdate) AddTime(i int) *ItemUpdate {
	iu.mutation.AddTime(i)
	return iu
}

// AddChildIDs adds the "children" edge to the Item entity by IDs.
func (iu *ItemUpdate) AddChildIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddChildIDs(ids...)
	return iu
}

// AddChildren adds the "children" edges to the Item entity.
func (iu *ItemUpdate) AddChildren(i ...*Item) *ItemUpdate {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddChildIDs(ids...)
}

// AddParentIDs adds the "parents" edge to the Item entity by IDs.
func (iu *ItemUpdate) AddParentIDs(ids ...string) *ItemUpdate {
	iu.mutation.AddParentIDs(ids...)
	return iu
}

// AddParents adds the "parents" edges to the Item entity.
func (iu *ItemUpdate) AddParents(i ...*Item) *ItemUpdate {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.AddParentIDs(ids...)
}

// Mutation returns the ItemMutation object of the builder.
func (iu *ItemUpdate) Mutation() *ItemMutation {
	return iu.mutation
}

// ClearChildren clears all "children" edges to the Item entity.
func (iu *ItemUpdate) ClearChildren() *ItemUpdate {
	iu.mutation.ClearChildren()
	return iu
}

// RemoveChildIDs removes the "children" edge to Item entities by IDs.
func (iu *ItemUpdate) RemoveChildIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveChildIDs(ids...)
	return iu
}

// RemoveChildren removes "children" edges to Item entities.
func (iu *ItemUpdate) RemoveChildren(i ...*Item) *ItemUpdate {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveChildIDs(ids...)
}

// ClearParents clears all "parents" edges to the Item entity.
func (iu *ItemUpdate) ClearParents() *ItemUpdate {
	iu.mutation.ClearParents()
	return iu
}

// RemoveParentIDs removes the "parents" edge to Item entities by IDs.
func (iu *ItemUpdate) RemoveParentIDs(ids ...string) *ItemUpdate {
	iu.mutation.RemoveParentIDs(ids...)
	return iu
}

// RemoveParents removes "parents" edges to Item entities.
func (iu *ItemUpdate) RemoveParents(i ...*Item) *ItemUpdate {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iu.RemoveParentIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (iu *ItemUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, iu.sqlSave, iu.mutation, iu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (iu *ItemUpdate) SaveX(ctx context.Context) int {
	affected, err := iu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (iu *ItemUpdate) Exec(ctx context.Context) error {
	_, err := iu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iu *ItemUpdate) ExecX(ctx context.Context) {
	if err := iu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (iu *ItemUpdate) check() error {
	if v, ok := iu.mutation.GetType(); ok {
		if err := item.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Item.type": %w`, err)}
		}
	}
	return nil
}

func (iu *ItemUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := iu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(item.Table, item.Columns, sqlgraph.NewFieldSpec(item.FieldID, field.TypeString))
	if ps := iu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := iu.mutation.Deleted(); ok {
		_spec.SetField(item.FieldDeleted, field.TypeBool, value)
	}
	if value, ok := iu.mutation.GetType(); ok {
		_spec.SetField(item.FieldType, field.TypeEnum, value)
	}
	if value, ok := iu.mutation.By(); ok {
		_spec.SetField(item.FieldBy, field.TypeString, value)
	}
	if iu.mutation.ByCleared() {
		_spec.ClearField(item.FieldBy, field.TypeString)
	}
	if value, ok := iu.mutation.Text(); ok {
		_spec.SetField(item.FieldText, field.TypeString, value)
	}
	if iu.mutation.TextCleared() {
		_spec.ClearField(item.FieldText, field.TypeString)
	}
	if value, ok := iu.mutation.Dead(); ok {
		_spec.SetField(item.FieldDead, field.TypeBool, value)
	}
	if value, ok := iu.mutation.Parent(); ok {
		_spec.SetField(item.FieldParent, field.TypeInt, value)
	}
	if value, ok := iu.mutation.AddedParent(); ok {
		_spec.AddField(item.FieldParent, field.TypeInt, value)
	}
	if iu.mutation.ParentCleared() {
		_spec.ClearField(item.FieldParent, field.TypeInt)
	}
	if value, ok := iu.mutation.Poll(); ok {
		_spec.SetField(item.FieldPoll, field.TypeInt, value)
	}
	if value, ok := iu.mutation.AddedPoll(); ok {
		_spec.AddField(item.FieldPoll, field.TypeInt, value)
	}
	if iu.mutation.PollCleared() {
		_spec.ClearField(item.FieldPoll, field.TypeInt)
	}
	if value, ok := iu.mutation.Kids(); ok {
		_spec.SetField(item.FieldKids, field.TypeJSON, value)
	}
	if value, ok := iu.mutation.AppendedKids(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, item.FieldKids, value)
		})
	}
	if iu.mutation.KidsCleared() {
		_spec.ClearField(item.FieldKids, field.TypeJSON)
	}
	if value, ok := iu.mutation.URL(); ok {
		_spec.SetField(item.FieldURL, field.TypeString, value)
	}
	if iu.mutation.URLCleared() {
		_spec.ClearField(item.FieldURL, field.TypeString)
	}
	if value, ok := iu.mutation.Score(); ok {
		_spec.SetField(item.FieldScore, field.TypeInt, value)
	}
	if value, ok := iu.mutation.AddedScore(); ok {
		_spec.AddField(item.FieldScore, field.TypeInt, value)
	}
	if iu.mutation.ScoreCleared() {
		_spec.ClearField(item.FieldScore, field.TypeInt)
	}
	if value, ok := iu.mutation.Title(); ok {
		_spec.SetField(item.FieldTitle, field.TypeString, value)
	}
	if iu.mutation.TitleCleared() {
		_spec.ClearField(item.FieldTitle, field.TypeString)
	}
	if value, ok := iu.mutation.Parts(); ok {
		_spec.SetField(item.FieldParts, field.TypeJSON, value)
	}
	if value, ok := iu.mutation.AppendedParts(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, item.FieldParts, value)
		})
	}
	if iu.mutation.PartsCleared() {
		_spec.ClearField(item.FieldParts, field.TypeJSON)
	}
	if value, ok := iu.mutation.Descendants(); ok {
		_spec.SetField(item.FieldDescendants, field.TypeInt, value)
	}
	if value, ok := iu.mutation.AddedDescendants(); ok {
		_spec.AddField(item.FieldDescendants, field.TypeInt, value)
	}
	if iu.mutation.DescendantsCleared() {
		_spec.ClearField(item.FieldDescendants, field.TypeInt)
	}
	if value, ok := iu.mutation.Time(); ok {
		_spec.SetField(item.FieldTime, field.TypeInt, value)
	}
	if value, ok := iu.mutation.AddedTime(); ok {
		_spec.AddField(item.FieldTime, field.TypeInt, value)
	}
	if iu.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   item.ChildrenTable,
			Columns: item.ChildrenPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedChildrenIDs(); len(nodes) > 0 && !iu.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   item.ChildrenTable,
			Columns: item.ChildrenPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.ChildrenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   item.ChildrenTable,
			Columns: item.ChildrenPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iu.mutation.ParentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.ParentsTable,
			Columns: item.ParentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.RemovedParentsIDs(); len(nodes) > 0 && !iu.mutation.ParentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.ParentsTable,
			Columns: item.ParentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.mutation.ParentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.ParentsTable,
			Columns: item.ParentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, iu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{item.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	iu.mutation.done = true
	return n, nil
}

// ItemUpdateOne is the builder for updating a single Item entity.
type ItemUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ItemMutation
}

// SetDeleted sets the "deleted" field.
func (iuo *ItemUpdateOne) SetDeleted(b bool) *ItemUpdateOne {
	iuo.mutation.SetDeleted(b)
	return iuo
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableDeleted(b *bool) *ItemUpdateOne {
	if b != nil {
		iuo.SetDeleted(*b)
	}
	return iuo
}

// SetType sets the "type" field.
func (iuo *ItemUpdateOne) SetType(i item.Type) *ItemUpdateOne {
	iuo.mutation.SetType(i)
	return iuo
}

// SetNillableType sets the "type" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableType(i *item.Type) *ItemUpdateOne {
	if i != nil {
		iuo.SetType(*i)
	}
	return iuo
}

// SetBy sets the "by" field.
func (iuo *ItemUpdateOne) SetBy(s string) *ItemUpdateOne {
	iuo.mutation.SetBy(s)
	return iuo
}

// SetNillableBy sets the "by" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableBy(s *string) *ItemUpdateOne {
	if s != nil {
		iuo.SetBy(*s)
	}
	return iuo
}

// ClearBy clears the value of the "by" field.
func (iuo *ItemUpdateOne) ClearBy() *ItemUpdateOne {
	iuo.mutation.ClearBy()
	return iuo
}

// SetText sets the "text" field.
func (iuo *ItemUpdateOne) SetText(s string) *ItemUpdateOne {
	iuo.mutation.SetText(s)
	return iuo
}

// SetNillableText sets the "text" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableText(s *string) *ItemUpdateOne {
	if s != nil {
		iuo.SetText(*s)
	}
	return iuo
}

// ClearText clears the value of the "text" field.
func (iuo *ItemUpdateOne) ClearText() *ItemUpdateOne {
	iuo.mutation.ClearText()
	return iuo
}

// SetDead sets the "dead" field.
func (iuo *ItemUpdateOne) SetDead(b bool) *ItemUpdateOne {
	iuo.mutation.SetDead(b)
	return iuo
}

// SetNillableDead sets the "dead" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableDead(b *bool) *ItemUpdateOne {
	if b != nil {
		iuo.SetDead(*b)
	}
	return iuo
}

// SetParent sets the "parent" field.
func (iuo *ItemUpdateOne) SetParent(i int) *ItemUpdateOne {
	iuo.mutation.ResetParent()
	iuo.mutation.SetParent(i)
	return iuo
}

// SetNillableParent sets the "parent" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableParent(i *int) *ItemUpdateOne {
	if i != nil {
		iuo.SetParent(*i)
	}
	return iuo
}

// AddParent adds i to the "parent" field.
func (iuo *ItemUpdateOne) AddParent(i int) *ItemUpdateOne {
	iuo.mutation.AddParent(i)
	return iuo
}

// ClearParent clears the value of the "parent" field.
func (iuo *ItemUpdateOne) ClearParent() *ItemUpdateOne {
	iuo.mutation.ClearParent()
	return iuo
}

// SetPoll sets the "poll" field.
func (iuo *ItemUpdateOne) SetPoll(i int) *ItemUpdateOne {
	iuo.mutation.ResetPoll()
	iuo.mutation.SetPoll(i)
	return iuo
}

// SetNillablePoll sets the "poll" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillablePoll(i *int) *ItemUpdateOne {
	if i != nil {
		iuo.SetPoll(*i)
	}
	return iuo
}

// AddPoll adds i to the "poll" field.
func (iuo *ItemUpdateOne) AddPoll(i int) *ItemUpdateOne {
	iuo.mutation.AddPoll(i)
	return iuo
}

// ClearPoll clears the value of the "poll" field.
func (iuo *ItemUpdateOne) ClearPoll() *ItemUpdateOne {
	iuo.mutation.ClearPoll()
	return iuo
}

// SetKids sets the "kids" field.
func (iuo *ItemUpdateOne) SetKids(i []int) *ItemUpdateOne {
	iuo.mutation.SetKids(i)
	return iuo
}

// AppendKids appends i to the "kids" field.
func (iuo *ItemUpdateOne) AppendKids(i []int) *ItemUpdateOne {
	iuo.mutation.AppendKids(i)
	return iuo
}

// ClearKids clears the value of the "kids" field.
func (iuo *ItemUpdateOne) ClearKids() *ItemUpdateOne {
	iuo.mutation.ClearKids()
	return iuo
}

// SetURL sets the "url" field.
func (iuo *ItemUpdateOne) SetURL(s string) *ItemUpdateOne {
	iuo.mutation.SetURL(s)
	return iuo
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableURL(s *string) *ItemUpdateOne {
	if s != nil {
		iuo.SetURL(*s)
	}
	return iuo
}

// ClearURL clears the value of the "url" field.
func (iuo *ItemUpdateOne) ClearURL() *ItemUpdateOne {
	iuo.mutation.ClearURL()
	return iuo
}

// SetScore sets the "score" field.
func (iuo *ItemUpdateOne) SetScore(i int) *ItemUpdateOne {
	iuo.mutation.ResetScore()
	iuo.mutation.SetScore(i)
	return iuo
}

// SetNillableScore sets the "score" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableScore(i *int) *ItemUpdateOne {
	if i != nil {
		iuo.SetScore(*i)
	}
	return iuo
}

// AddScore adds i to the "score" field.
func (iuo *ItemUpdateOne) AddScore(i int) *ItemUpdateOne {
	iuo.mutation.AddScore(i)
	return iuo
}

// ClearScore clears the value of the "score" field.
func (iuo *ItemUpdateOne) ClearScore() *ItemUpdateOne {
	iuo.mutation.ClearScore()
	return iuo
}

// SetTitle sets the "title" field.
func (iuo *ItemUpdateOne) SetTitle(s string) *ItemUpdateOne {
	iuo.mutation.SetTitle(s)
	return iuo
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableTitle(s *string) *ItemUpdateOne {
	if s != nil {
		iuo.SetTitle(*s)
	}
	return iuo
}

// ClearTitle clears the value of the "title" field.
func (iuo *ItemUpdateOne) ClearTitle() *ItemUpdateOne {
	iuo.mutation.ClearTitle()
	return iuo
}

// SetParts sets the "parts" field.
func (iuo *ItemUpdateOne) SetParts(i []int) *ItemUpdateOne {
	iuo.mutation.SetParts(i)
	return iuo
}

// AppendParts appends i to the "parts" field.
func (iuo *ItemUpdateOne) AppendParts(i []int) *ItemUpdateOne {
	iuo.mutation.AppendParts(i)
	return iuo
}

// ClearParts clears the value of the "parts" field.
func (iuo *ItemUpdateOne) ClearParts() *ItemUpdateOne {
	iuo.mutation.ClearParts()
	return iuo
}

// SetDescendants sets the "descendants" field.
func (iuo *ItemUpdateOne) SetDescendants(i int) *ItemUpdateOne {
	iuo.mutation.ResetDescendants()
	iuo.mutation.SetDescendants(i)
	return iuo
}

// SetNillableDescendants sets the "descendants" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableDescendants(i *int) *ItemUpdateOne {
	if i != nil {
		iuo.SetDescendants(*i)
	}
	return iuo
}

// AddDescendants adds i to the "descendants" field.
func (iuo *ItemUpdateOne) AddDescendants(i int) *ItemUpdateOne {
	iuo.mutation.AddDescendants(i)
	return iuo
}

// ClearDescendants clears the value of the "descendants" field.
func (iuo *ItemUpdateOne) ClearDescendants() *ItemUpdateOne {
	iuo.mutation.ClearDescendants()
	return iuo
}

// SetTime sets the "time" field.
func (iuo *ItemUpdateOne) SetTime(i int) *ItemUpdateOne {
	iuo.mutation.ResetTime()
	iuo.mutation.SetTime(i)
	return iuo
}

// SetNillableTime sets the "time" field if the given value is not nil.
func (iuo *ItemUpdateOne) SetNillableTime(i *int) *ItemUpdateOne {
	if i != nil {
		iuo.SetTime(*i)
	}
	return iuo
}

// AddTime adds i to the "time" field.
func (iuo *ItemUpdateOne) AddTime(i int) *ItemUpdateOne {
	iuo.mutation.AddTime(i)
	return iuo
}

// AddChildIDs adds the "children" edge to the Item entity by IDs.
func (iuo *ItemUpdateOne) AddChildIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddChildIDs(ids...)
	return iuo
}

// AddChildren adds the "children" edges to the Item entity.
func (iuo *ItemUpdateOne) AddChildren(i ...*Item) *ItemUpdateOne {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddChildIDs(ids...)
}

// AddParentIDs adds the "parents" edge to the Item entity by IDs.
func (iuo *ItemUpdateOne) AddParentIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.AddParentIDs(ids...)
	return iuo
}

// AddParents adds the "parents" edges to the Item entity.
func (iuo *ItemUpdateOne) AddParents(i ...*Item) *ItemUpdateOne {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.AddParentIDs(ids...)
}

// Mutation returns the ItemMutation object of the builder.
func (iuo *ItemUpdateOne) Mutation() *ItemMutation {
	return iuo.mutation
}

// ClearChildren clears all "children" edges to the Item entity.
func (iuo *ItemUpdateOne) ClearChildren() *ItemUpdateOne {
	iuo.mutation.ClearChildren()
	return iuo
}

// RemoveChildIDs removes the "children" edge to Item entities by IDs.
func (iuo *ItemUpdateOne) RemoveChildIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveChildIDs(ids...)
	return iuo
}

// RemoveChildren removes "children" edges to Item entities.
func (iuo *ItemUpdateOne) RemoveChildren(i ...*Item) *ItemUpdateOne {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveChildIDs(ids...)
}

// ClearParents clears all "parents" edges to the Item entity.
func (iuo *ItemUpdateOne) ClearParents() *ItemUpdateOne {
	iuo.mutation.ClearParents()
	return iuo
}

// RemoveParentIDs removes the "parents" edge to Item entities by IDs.
func (iuo *ItemUpdateOne) RemoveParentIDs(ids ...string) *ItemUpdateOne {
	iuo.mutation.RemoveParentIDs(ids...)
	return iuo
}

// RemoveParents removes "parents" edges to Item entities.
func (iuo *ItemUpdateOne) RemoveParents(i ...*Item) *ItemUpdateOne {
	ids := make([]string, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return iuo.RemoveParentIDs(ids...)
}

// Where appends a list predicates to the ItemUpdate builder.
func (iuo *ItemUpdateOne) Where(ps ...predicate.Item) *ItemUpdateOne {
	iuo.mutation.Where(ps...)
	return iuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (iuo *ItemUpdateOne) Select(field string, fields ...string) *ItemUpdateOne {
	iuo.fields = append([]string{field}, fields...)
	return iuo
}

// Save executes the query and returns the updated Item entity.
func (iuo *ItemUpdateOne) Save(ctx context.Context) (*Item, error) {
	return withHooks(ctx, iuo.sqlSave, iuo.mutation, iuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (iuo *ItemUpdateOne) SaveX(ctx context.Context) *Item {
	node, err := iuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (iuo *ItemUpdateOne) Exec(ctx context.Context) error {
	_, err := iuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iuo *ItemUpdateOne) ExecX(ctx context.Context) {
	if err := iuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (iuo *ItemUpdateOne) check() error {
	if v, ok := iuo.mutation.GetType(); ok {
		if err := item.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Item.type": %w`, err)}
		}
	}
	return nil
}

func (iuo *ItemUpdateOne) sqlSave(ctx context.Context) (_node *Item, err error) {
	if err := iuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(item.Table, item.Columns, sqlgraph.NewFieldSpec(item.FieldID, field.TypeString))
	id, ok := iuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Item.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := iuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, item.FieldID)
		for _, f := range fields {
			if !item.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != item.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := iuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := iuo.mutation.Deleted(); ok {
		_spec.SetField(item.FieldDeleted, field.TypeBool, value)
	}
	if value, ok := iuo.mutation.GetType(); ok {
		_spec.SetField(item.FieldType, field.TypeEnum, value)
	}
	if value, ok := iuo.mutation.By(); ok {
		_spec.SetField(item.FieldBy, field.TypeString, value)
	}
	if iuo.mutation.ByCleared() {
		_spec.ClearField(item.FieldBy, field.TypeString)
	}
	if value, ok := iuo.mutation.Text(); ok {
		_spec.SetField(item.FieldText, field.TypeString, value)
	}
	if iuo.mutation.TextCleared() {
		_spec.ClearField(item.FieldText, field.TypeString)
	}
	if value, ok := iuo.mutation.Dead(); ok {
		_spec.SetField(item.FieldDead, field.TypeBool, value)
	}
	if value, ok := iuo.mutation.Parent(); ok {
		_spec.SetField(item.FieldParent, field.TypeInt, value)
	}
	if value, ok := iuo.mutation.AddedParent(); ok {
		_spec.AddField(item.FieldParent, field.TypeInt, value)
	}
	if iuo.mutation.ParentCleared() {
		_spec.ClearField(item.FieldParent, field.TypeInt)
	}
	if value, ok := iuo.mutation.Poll(); ok {
		_spec.SetField(item.FieldPoll, field.TypeInt, value)
	}
	if value, ok := iuo.mutation.AddedPoll(); ok {
		_spec.AddField(item.FieldPoll, field.TypeInt, value)
	}
	if iuo.mutation.PollCleared() {
		_spec.ClearField(item.FieldPoll, field.TypeInt)
	}
	if value, ok := iuo.mutation.Kids(); ok {
		_spec.SetField(item.FieldKids, field.TypeJSON, value)
	}
	if value, ok := iuo.mutation.AppendedKids(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, item.FieldKids, value)
		})
	}
	if iuo.mutation.KidsCleared() {
		_spec.ClearField(item.FieldKids, field.TypeJSON)
	}
	if value, ok := iuo.mutation.URL(); ok {
		_spec.SetField(item.FieldURL, field.TypeString, value)
	}
	if iuo.mutation.URLCleared() {
		_spec.ClearField(item.FieldURL, field.TypeString)
	}
	if value, ok := iuo.mutation.Score(); ok {
		_spec.SetField(item.FieldScore, field.TypeInt, value)
	}
	if value, ok := iuo.mutation.AddedScore(); ok {
		_spec.AddField(item.FieldScore, field.TypeInt, value)
	}
	if iuo.mutation.ScoreCleared() {
		_spec.ClearField(item.FieldScore, field.TypeInt)
	}
	if value, ok := iuo.mutation.Title(); ok {
		_spec.SetField(item.FieldTitle, field.TypeString, value)
	}
	if iuo.mutation.TitleCleared() {
		_spec.ClearField(item.FieldTitle, field.TypeString)
	}
	if value, ok := iuo.mutation.Parts(); ok {
		_spec.SetField(item.FieldParts, field.TypeJSON, value)
	}
	if value, ok := iuo.mutation.AppendedParts(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, item.FieldParts, value)
		})
	}
	if iuo.mutation.PartsCleared() {
		_spec.ClearField(item.FieldParts, field.TypeJSON)
	}
	if value, ok := iuo.mutation.Descendants(); ok {
		_spec.SetField(item.FieldDescendants, field.TypeInt, value)
	}
	if value, ok := iuo.mutation.AddedDescendants(); ok {
		_spec.AddField(item.FieldDescendants, field.TypeInt, value)
	}
	if iuo.mutation.DescendantsCleared() {
		_spec.ClearField(item.FieldDescendants, field.TypeInt)
	}
	if value, ok := iuo.mutation.Time(); ok {
		_spec.SetField(item.FieldTime, field.TypeInt, value)
	}
	if value, ok := iuo.mutation.AddedTime(); ok {
		_spec.AddField(item.FieldTime, field.TypeInt, value)
	}
	if iuo.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   item.ChildrenTable,
			Columns: item.ChildrenPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedChildrenIDs(); len(nodes) > 0 && !iuo.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   item.ChildrenTable,
			Columns: item.ChildrenPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.ChildrenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   item.ChildrenTable,
			Columns: item.ChildrenPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if iuo.mutation.ParentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.ParentsTable,
			Columns: item.ParentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.RemovedParentsIDs(); len(nodes) > 0 && !iuo.mutation.ParentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.ParentsTable,
			Columns: item.ParentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.mutation.ParentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   item.ParentsTable,
			Columns: item.ParentsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(item.FieldID, field.TypeString),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Item{config: iuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, iuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{item.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	iuo.mutation.done = true
	return _node, nil
}
